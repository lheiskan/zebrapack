package parse

import (
	"errors"
	"fmt"
	"sort"

	"github.com/glycerine/zebrapack/gen"
	"github.com/glycerine/zebrapack/zebra"
	//"github.com/shurcooL/go-goon"
)

// TranslateToZebraSchema takes the FileSet already in `fs`,
// assumes it was generated by parsing `path` (to Go
// source file), and returns a ZebraPack specified schema;
// i.e. a *zebra.Schema.
// TODO: handled top-level arrays/other types besides structs.
// Currently we only record structs.
func TranslateToZebraSchema(path string, fs *FileSet) (*zebra.Schema, error) {

	structs := make(map[string]*zebra.Struct)

	for _, ele := range fs.Identities {

		switch x := ele.(type) {
		case *gen.Struct:
			tr := zebra.Struct{
				StructName: x.TypeName(),
			}
			for _, f := range x.Fields {
				zc, zp := getCatPrimiType(&f)
				//fmt.Printf("\n on f = %#v\n", f)
				//goon.Dump(f)
				fld := zebra.Field{
					Zid:            f.ZebraId,
					OmitEmpty:      f.OmitEmpty,
					Skip:           f.Skip,
					FieldGoName:    f.FieldName,
					FieldTagName:   f.FieldTag,
					FieldCategory:  zc,
					FieldPrimitive: zp,
					Deprecated:     f.Deprecated,
					ShowZero:       f.ShowZero,
				}
				if !fld.Skip {
					zt := f.FieldElem.GetZtype()
					fld.FieldFullType = &zt
					fld.FieldTypeStr = f.FieldElem.TypeName()
				}
				//fmt.Printf("\n in %v,  on field %#v ... fld='%#v'\n", tr.StructName, f, fld)
				tr.Fields = append(tr.Fields, fld)
			}

			// Sort fields ascending by Zid
			sort.SliceStable(tr.Fields, func(i, j int) bool {
				return tr.Fields[i].Zid < tr.Fields[j].Zid
			})

			// Sanity check fields. There should be no gaps and no duplicates in zid. Numbering should start from 0
			for i:=0;i<len(tr.Fields);i++ {
				if int64(i) != tr.Fields[i].Zid {
					return nil, errors.New(fmt.Sprintf("Bad schema: %s, has bad zip %d. zid:s should start from 0, increase with no gaps and have no duplicates.", tr.StructName, i))
				}
			}

			structs[tr.StructName] = &tr
			//structs = append(structs, tr)
			/*
				case *Ptr:
				case *Array:
				case *Slice:
				case *Map:
				case *BaseElem:
			*/
		default:
			//fmt.Fprintf(os.Stderr, "\nwarning: ignoring type '%v'; we only support top-level structs in a schema at present.\n", x.TypeName())
			//return nil, fmt.Errorf("unhandled type %T", x)
		}
	}
	imports := []string{}
	for _, imp := range fs.Imports {
		n := ""
		if imp.Name != nil {
			n = imp.Name.Name // local package name (including "."); or nil
		}
		p := imp.Path.Value // import path
		if len(n) > 0 {
			imports = append(imports, fmt.Sprintf("%s %s", n, p))
		} else {
			imports = append(imports, p)
		}
	}

	sch := &zebra.Schema{
		SourcePath:    path,
		SourcePackage: fs.Package,
		ZebraSchemaId: fs.ZebraSchemaId,
		Structs:       structs,
		Imports:       imports,
	}
	//fmt.Printf("total number of structs: %v\n", len(structs))
	//fmt.Printf("total number of fields in first struct: %v\n", len(structs[0].Fields))
	return sch, nil

}

func getCatPrimiType(f *gen.StructField) (zc zebra.Zkind, zp zebra.Zkind) {
	switch e := f.FieldElem.(type) {
	case *gen.Map:
		zc = zebra.MapCat
	case *gen.Struct:
		zc = zebra.StructCat
	case *gen.Slice:
		zc = zebra.SliceCat
	case *gen.Array:
		zc = zebra.ArrayCat
	case *gen.Ptr:
		zc = zebra.PointerCat
	case *gen.BaseElem:
		zc = zebra.BaseElemCat
		zp = zebra.Zkind(e.Value)
	case nil:
		// struct{} or other skippable, default 0, 0 is fine.
	default:
		panic(fmt.Errorf("bad element type %T", e))
	}

	return
}
